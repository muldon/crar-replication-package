Query: Doc, rtf and txt reader in python
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/3278898)
 You can read a text file with 

  txt = open("file.txt").read()
  

 Try http://pyrtf.sourceforge.net/ for RTF files. I would think that reading MS Word .doc files are pretty unlikely unless you are on Windows and you can use some of the native MS interfaces for reading those files. http://www.python.org/about/success/honeywell/ claims to show how to write scripts that interface with Word. 


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/17959738)
 That's because rtf isn't just plain text format. Save it as  python_file.txt  for example or create file that compatibile with rtf format, for example: 

  >>> infile=open("python_file.rtf","w")
>>> infile.write("{\r test \par }")
>>> infile.close()
  


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/30123122)
 I've had a real headache trying to do this simple thing for word and writer documents. 

 There is a simple solution: call openoffice on the command line to convert your target document to text, then load the text into Python. 

 Other conversion tools I tried produced unreliable output, while other Python oOo libraries were too complex. 

 If you just want to get at the text so you can process it, use this on the linux command line: 

  soffice --headless --convert-to txt:Text /path_to/document_to_convert.doc
  

 (call it from Python using subprocess if you want to automate it). 

 It will create text file you can simpley load into python. 

 (http://ask.libreoffice.org/en/question/14130/how-do-i-install-filters-for-the-soffice-command/) 


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/1821405)
 I've been working on a library called Pyth, which can do this: 

 http://pypi.python.org/pypi/pyth/ 

 Converting an RTF file to plaintext looks something like this: 

  from pyth.plugins.rtf15.reader import Rtf15Reader
from pyth.plugins.plaintext.writer import PlaintextWriter

doc = Rtf15Reader.read(open('sample.rtf'))

print PlaintextWriter.write(doc).getvalue()
  

 Pyth can also generate RTF files, read and write XHTML, generate documents from Python markup a la Nevow's stan, and has limited experimental support for latex and pdf output. Its RTF support is http://github.com/brendonh/pyth/blob/master/pyth/plugins/rtf15/reader.py -- we use it in production to read RTF files generated by various versions of Word, OpenOffice, Mac TextEdit, EIOffice, and others. 


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/15113980)
 It seems likely that there is an http://en.wikipedia.org/wiki/ANSI_escape_code in your   vera_en2.txt  that sets the font to italic. Open the file or print the  repr()  of the first line of that file to verify this. 

 Apparently you are working in an ANSI compatible terminal already, or you wouldn't be seeing italic text. So, you should be able to reset the font with  print("\033[0m") , and enable italics again with  print("\033[3m") . 

 If this all seems too esoteric, I recommend using https://pypi.python.org/pypi/colorama. 

  Edit:  

 Ah, so you want to write an RTF file with some italic text.  .txt files aren't actually .txt files. That's completely different from what I explained above. 

 By analyzing the plain text of an actual rtf I came up with this small example. It generate a small rtf file with normal, italic and bold words; \i and \b are used to toggle these formats. 

  # open file
myrtf = open('myrtf.rtf', 'w ')

# write some necessary header info
myrtf.write(r'{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}}')

# write the actual text - notice I'm using raw strings (r'')
myrtf.write(r'normal \i italic \i0 \b bold \b0 normal\n')

# write end of file stuff
myrtf.write(r'}\n\x00')

# close file
myrtf.close()
  

 Also, answering the other question; getting italics in the console might be difficult, most terminals just don't support it. 

 To adapt the above code sample to the problem in your question: 

  L1 = open ('file1.txt','r')
L2 = open ('file2.txt','r')
O = open ('output.rtf','w')

# write header
O.write(r'{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}}')

for line in L1:
    line2 = r"\i  " + L2.readline() + r" \i0\line\par" # make text from L2 italic
    print(line, end='')
    print(line2)
    O.write(line)
    O.write(line2)

# close rtf
O.write(r'}\n\x00')

L1.close()
L2.close()
O.close()
  

  Another addition:  

 Based on our discussion in the comments, here's one way to do it by writing a html file instead of rtf: 

  L1 = open ('file1.txt','r')
L2 = open ('file2.txt','r')
O = open ('output.html','w')

# write header
O.write(r'<html><head><title>Foobar</title></head><body><table>')

for line in L1:
    line2 = r"<i>" + L2.readline() + r"</i> " # make text from L2 italic
    O.write("<tr>")
    O.write("<td>%s</td>" % line)
    O.write("<td>%s</td>" % line2)
    O.write("</tr>\n")

# footer
O.write(r'</table></body></html>')

L1.close()
L2.close()
O.close()
  

 http://jsfiddle.net/mYJTb/ you can see the result when file1.txt and file2.txt are Old English and modern versions of a verse from Beowulf. 


-------------------------------------next answer-------------------------------------

Rank:6 (https://stackoverflow.com/questions/17959742)
 You try to save this to a http://en.wikipedia.org/wiki/Rich_Text_Format File, but  "insert string here"  is only a character sequence. Try to save it as  python_file.txt  and open it with a notepad application, then you should see the text. 

 If you want to save RTF files you should check how this files are internaly formated. For your example this would be: 

  infile=open("python_file.rtf","w")
infile.write("{\rtf1 insert string here }")
infile.close()
  


-------------------------------------next answer-------------------------------------

Rank:7 (https://stackoverflow.com/questions/42318291)
 don't use semicolons in python!
As suspected, you are trying to read a RTF file.  First reformat your file. I propose also an other way: 

  import csv

list1 = []
with open("extedit.txt") as tsv:
    for line in csv.reader(tsv, dialect="excel-tab"):
        list1.append(line[0])

del list1[0]
print(list1)
  


-------------------------------------next answer-------------------------------------

Rank:8 (https://stackoverflow.com/questions/3278949)
  csv  is a specific format so you need a "parser" to read it. This is what the csv module provides as you've mentioned. Text files (usually suffixed with  .txt ) don't have any fixed "format" so you can just read them after  open ing them (Jesse's answer gives the details). CSV files are commonly text files so your distinction is not very accurate.  

 As for RTF, There are a bunch of them. See https://stackoverflow.com/questions/1337446/is-there-a-python-module-for-converting-rtf-to-plain-text for details. The PyRTF thing which Jesse mentioned seems to be the most popular though. 

 Microsoft Word document files (usually suffixed with  .doc ) are another beast since the format is proprietary. I don't have much experience with Python converters but there are a few command line ones (like wvHTML) which do a somewhat decent job. https://stackoverflow.com/questions/685533/python-convert-microsoft-office-docs-to-plain-text-on-linux discusses quite a few. There's also the option of having MS-Word itself do that for you via. a COM interface like Jesse has mentioned.  


-------------------------------------next answer-------------------------------------

Rank:9 (https://stackoverflow.com/questions/17959741)
 RTF files are not text files.  You wrote a text file, but called it ".rtf", so your operating system is trying to treat it as an RTF, and failing because the contents don't match the RTF file format. 

 Change it to "python_file.txt" and I bet it'll work fine. 



