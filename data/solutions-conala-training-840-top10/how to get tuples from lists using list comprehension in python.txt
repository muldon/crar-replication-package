Query: how to get tuples from lists using list comprehension in python
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/13078663)
 Using a nested list comprehension: 

  >>> a = [[(1,2)], [(3,4), (5,6)], [(7,8), (9,10), (11,12)]]
>>> b = [[(x+1, y) for x, y in tuples] for tuples in a]
>>> b
[[(2, 2)], [(4, 4), (6, 6)], [(8, 8), (10, 10), (12, 12)]]
  

 As a  for  with a list comprehension: 

  b = []
for tuples in a:
    b.append([(x+1, y) for x, y in tuples])
  

 Without any list comprehension: 

  b = []
for tuples in a:
    tuples_b = []
    for x, y in tuples:
        tuples_b.append((x+1, y))
    b.append(tuples_b)
  


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/18990147)
 Think about list comprehensions as loops. How can you write 2 not nested loops? 

 You can do this with somewhat wierd list comprehension: 

  [(x, lst2[i]) f i, x in enumerate(lst)]
  

  

  [(lst[i], lst2[i]) f i in xrange(len(lst))]
  

 But actually, it's better to use  zip . 


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/14931808)
 Use http://docs.python.org/2/library/itertools.html#itertools.product 

  import itertools
lst = list(itertools.product([0, 1], repeat=3))
  

 This will yield a list of tuples (see http://ideone.com/rXZsIG) 

 You can easily change this to use a variable  repeat : 

  n = 3
lst = list(itertools.product([0, 1], repeat=n))
  

 If you need a list of lists, then you can use the  map  function (thanks @Aesthete). 

  lst = map(list, itertools.product([0, 1], repeat=n))
  

 Or in Python 3: 

  lst = list(map(list, itertools.product([0, 1], repeat=n)))
# OR
lst = [list(i) for i in itertools.product([0, 1], repeat=n)]
  

 Note that using  map  or a list comprehension means you don't need to convert the product into a list, as it will iterate through the  itertools.product  object and produce a list. 


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/16941245)
 Raymond Hettinger (one of the Python core developers) had this to say about tuples in a https://twitter.com/raymondh/status/324664257004322817: 

 
   #python tip:Generally, lists are for looping; tuples for structs. Lists are homogeneous; tuples heterogeneous.Lists for variable length. 
 

 This (to me) supports the idea that if the items in a sequence are related enough to be generated by a, well, generator, then it should be a list. Although a tuple is iterable and seems like simply a immutable list, it's really the Python equivalent of a C struct: 

  struct {
    int a;
    char b;
    float c;
} foo;

struct foo x = { 3, 'g', 5.9 };
  

 becomes in Python 

  x = (3, 'g', 5.9)
  


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/38620061)
  print('[' + ' '.join([str(tup) for tup in c]) + ']')
  

 Using a list comprehension to create a list of the tuples in string form. Those are then joined and the square brackets are added to make it look as you want it. 


-------------------------------------next answer-------------------------------------

Rank:6 (https://stackoverflow.com/questions/2169640)
 This takes  zip 's output and converts all tuples to lists: 

  map(list, zip(cities, airports))
  

  

  $ python -m timeit -c '[ [a, b] for a, b in zip(xrange(100), xrange(100)) ]'
10000 loops, best of 3: 68.3 usec per loop

$ python -m timeit -c 'map(list, zip(xrange(100), xrange(100)))'
10000 loops, best of 3: 75.4 usec per loop

$ python -m timeit -c '[ list(x) for x in zip(range(100), range(100)) ]'
10000 loops, best of 3: 99.9 usec per loop
  


-------------------------------------next answer-------------------------------------

Rank:7 (https://stackoverflow.com/questions/48300546)
 You need to write code that keeps the first of the sub-lists, dropping the rest. The simplest way to do this is to reverse  mylist , load it into an  dict  object, and retrieve its key-value pairs as lists again.  

  >>> list(map(list, dict(mylist).items()))
  

 Or, using a  list comprehension  - 

  >>> [list(v) for v in dict(mylist).items()]
  

  

  [['zzz', 171], ['yyy', 315], ['xxx', 879]]
  

 Note, that this answer does not maintain order! Also, if your sub-lists can have more than 2 elements, an approach involving hashing the tuplized versions of your data, as https://stackoverflow.com/a/48300720/4909087 shows, would be the best thing to do. 


-------------------------------------next answer-------------------------------------

Rank:8 (https://stackoverflow.com/questions/50681038)
 I'm surprised it seems nobody proposed  using a simple list comprehension : 

  joined_list = [y for x in [list_one, list_two] for y in x]
  

 It has all the advantages of the newest approach of using https://www.python.org/dev/peps/pep-0448/ - i.e. you can concatenate an arbitrary number of different iterables (e.g. lists, tuples, ranges, generators) that way - and it's not limited to  Python >= 3.5 . 


-------------------------------------next answer-------------------------------------

Rank:9 (https://stackoverflow.com/questions/18990108)
 The list comprehension way is silly, because it just wraps a do-nothing list comprehension around  zip : 

  [(i,j) for i, j in zip(lst, lst2)]
  

 Just use  zip , this is what it's for.  There's no sense in forcing yourself to use list comprehensions when they don't accomplish anything. 

 Edit: If your question is "how do I get two for loops in one list comprehension", you should ask that instead.  The answer is "You can't get two PARALLEL  for  loops in one list comprehension".  Any time you put two  for  clauses in a list comprehension, they will be nested.  That, a list comprehension like this: 

  [... for a in list1 for b in list2]
  

 Works like two nested  for  loops: 

  for a in list1:
    for b in list2:
        ...
  

 You can't write a list comprehension that does this: 

  for a in list1:
    ...
for b in list2:
    ...
  

 . . . and you don't need to, because you have the  zip  function to do that instead. 

 (You can sort of fake it using a solution like @Roman Pekar's, but that doesn't really do two  for  loops; it just does one and uses the values from that one to reach into the other list.) 


-------------------------------------next answer-------------------------------------

Rank:10 (https://stackoverflow.com/questions/3231353)
 Sounds like you want something like: 

  my_dict = {'test1420': {'y': '060', 'x': '070', 'fname': 'test1420'},
           'test277' : {'y': '072', 'x': '094', 'fname': 'test277'}}


new_dict = dict((k,v) for k,v in my_dict.items() 
                    if 92 < int(v['x']) < 95 and 70 < int(v['y']) < 75)
  

 Some notes on this code: 

 
 I'm using a generator expression
instead of a list comprehension 
 Python lets you combine inequality
tests as  low < value < high   
 The dict() constructor takes an iterable
of key/value tuples to create a
dictionary 
 



