Query: All combinations of a list of lists
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/35464452)
   

  >>> import itertools
>>> x = [['a', 'b', 'c'], [1, 2, 3], ['x', 'y']] # your list of lists
>>> [tup for sublist in [itertools.product(*x[:n+1]) for n in range(len(x))] 
         for tup in sublist]
[('a',), ('b',), ('c',), 
 ('a', 1), ('a', 2), ('a', 3), 
 ('b', 1), ('b', 2), ('b', 3), 
 ('c', 1), ('c', 2), ('c', 3), 
 ('a', 1, 'x'), ('a', 1, 'y'), ('a', 2, 'x'), ('a', 2, 'y'), ('a', 3, 'x'), ('a', 3, 'y'), 
 ('b', 1, 'x'), ('b', 1, 'y'), ('b', 2, 'x'), ('b', 2, 'y'), ('b', 3, 'x'), ('b', 3, 'y'), 
 ('c', 1, 'x'), ('c', 1, 'y'), ('c', 2, 'x'), ('c', 2, 'y'), ('c', 3, 'x'), ('c', 3, 'y')]
  

 You just need to take  itertools.product  over all prefixes of your list of lists (i.e.  x[:1] ,  x[:2] , ...). The outer list comprehension is just for flattening the list-of-lists generated by the inner list comprehension. 


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/798893)
 you need https://docs.python.org/2/library/itertools.html#itertools.product: 

  >>> import itertools
>>> a = [[1,2,3],[4,5,6],[7,8,9,10]]
>>> list(itertools.product(*a))
[(1, 4, 7), (1, 4, 8), (1, 4, 9), (1, 4, 10), (1, 5, 7), (1, 5, 8), (1, 5, 9), (1, 5, 10), (1, 6, 7), (1, 6, 8), (1, 6, 9), (1, 6, 10), (2, 4, 7), (2, 4, 8), (2, 4, 9), (2, 4, 10), (2, 5, 7), (2, 5, 8), (2, 5, 9), (2, 5, 10), (2, 6, 7), (2, 6, 8), (2, 6, 9), (2, 6, 10), (3, 4, 7), (3, 4, 8), (3, 4, 9), (3, 4, 10), (3, 5, 7), (3, 5, 8), (3, 5, 9), (3, 5, 10), (3, 6, 7), (3, 6, 8), (3, 6, 9), (3, 6, 10)]
  


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/12806000)
 You can use http://docs.python.org/library/itertools.html#itertools.product for this: 

  >>> import itertools
>>> lists = [[1], [2, 3], [4, 5]]
>>> list(itertools.product(*lists))
[(1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5)]
  


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/8371904)
 .  All you need to do to convert these into lists is call  list()  on the result. 

 However, since you will need to call  itertools.combinations  three separate times (once for each different length), you can just use  list.extend  to add all elements of the iterator to your final list. 

 Try the following: 

  import itertools
in_list = [1, 2, 3]
out_list = []
for i in range(1, len(in_list)+1):
    out_list.extend(itertools.combinations(in_list, i))
  

 Or as a list comprehension: 

  out_list = [c for i in range(len(in_list)) for c in itertools.combinations(in_list, i+1)]
  

 These will result in the following list: 

  [(1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
  

 If you want lists instead of tuples, and to convert the single length tuples to just the value, you can do the following: 

  out_list = [x[0] if len(x) == 1 else list(x) for x in out_list]
# [1, 2, 3, [1, 2], [1, 3], [2, 3], [1, 2, 3]]
  

 Or to leave the single items as lists: 

  out_list = map(list, out_list)
  


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/35464509)
 You can use   itertools.combinations  and  itertools.product()  within a list comprehension to calculate the product of all single, pair and triples : 

  >>> from itertools import product
>>> lst = [['a','b','c'],[1,2,3],['x','y']]
>>> [[list(product(*t)) for t in combinations(lst,i)] for i in range(1,len(lst)+1)]
[[[('a',), ('b',), ('c',)], [(1,), (2,), (3,)], [('x',), ('y',)]], 
 [[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3)], [('a', 'x'), ('a', 'y'), ('b', 'x'), ('b', 'y'), ('c', 'x'), ('c', 'y')], [(1, 'x'), (1, 'y'), (2, 'x'), (2, 'y'), (3, 'x'), (3, 'y')]],
[[('a', 1, 'x'), ('a', 1, 'y'), ('a', 2, 'x'), ('a', 2, 'y'), ('a', 3, 'x'), ('a', 3, 'y'), ('b', 1, 'x'), ('b', 1, 'y'), ('b', 2, 'x'), ('b', 2, 'y'), ('b', 3, 'x'), ('b', 3, 'y'), ('c', 1, 'x'), ('c', 1, 'y'), ('c', 2, 'x'), ('c', 2, 'y'), ('c', 3, 'x'), ('c', 3, 'y')]]]
  


-------------------------------------next answer-------------------------------------

Rank:6 (https://stackoverflow.com/questions/41527794)
 Numpy can do it: 

   >>> import numpy
 >>> a = [[1,2,3],[4,5,6],[7,8,9,10]]
 >>> [list(x) for x in numpy.array(numpy.meshgrid(*a)).T.reshape(-1,len(a))]
[[ 1, 4, 7], [1, 5, 7], [1, 6, 7], ....]
  


-------------------------------------next answer-------------------------------------

Rank:7 (https://stackoverflow.com/questions/24808893)
 You could use  itertools.product  to make all possible combinations from your lists. The result will be one long list of  tuple  with an element from each list in the order you passed the list in. 

  >>> a = [1,2,3]
>>> b = ['a', 'b', 'c']
>>> c = [4,5,6]
>>> import itertools

>>> list(itertools.product(a,b,c))
[(1, 'a', 4), (1, 'a', 5), (1, 'a', 6), (1, 'b', 4), (1, 'b', 5), (1, 'b', 6), (1, 'c', 4), (1, 'c', 5), (1, 'c', 6),
 (2, 'a', 4), (2, 'a', 5), (2, 'a', 6), (2, 'b', 4), (2, 'b', 5), (2, 'b', 6), (2, 'c', 4), (2, 'c', 5), (2, 'c', 6),
(3, 'a', 4), (3, 'a', 5), (3, 'a', 6), (3, 'b', 4), (3, 'b', 5), (3, 'b', 6), (3, 'c', 4), (3, 'c', 5), (3, 'c', 6)]
  

 For example 

  l = list(itertools.product(a,b,c))
for ai, bi, ci in l:
    print ai, bi, ci
  

 Output  

  1 a 4
1 a 5
1 a 6
... etc
  


-------------------------------------next answer-------------------------------------

Rank:8 (https://stackoverflow.com/questions/34308942)
 If it will always happen that 3 list will form numbers from 0-23, and you only want first list, then this can be done by creating combinations of length 3, and then set intersection: 

  >>> li = [[0,2,5,8,7,12,16,18], [0,9,18,23,5,8,15,16], [1,3,4,17,19,6,13,23], [9,22,21,10,11,20,14,15], [2,8,23,0,7,16,9,15], [0,5,8,7,9,11,20,16]]

>>> import itertools
>>> for t in itertools.combinations(li, 3):
...     if not set(t[0]) & set(t[1]) and not set(t[0]) & set(t[2]) and not set(t[1]) & set(t[2]):
...         print t
...         break
([0, 2, 5, 8, 7, 12, 16, 18], [1, 3, 4, 17, 19, 6, 13, 23], [9, 22, 21, 10, 11, 20, 14, 15])
  


-------------------------------------next answer-------------------------------------

Rank:9 (https://stackoverflow.com/questions/35464972)
 The previous posts have offered concise solutions involving nested comprehensions, but are missing several products of possible sets of sublists like  ('a', 'x') . I will try to break it down in a more readable way: 

  lst = [['a', 'b', 'c'], [1, 2, 3], ['x', 'y']]
result = []  # collect your products

# n sublists: iterate over all 'sub_lengthes'
for length in xrange(1, len(lst)+1):
    # iterate over all possible combinations of sublists
    for c in itertools.combinations(lst, length):
        # iterate over all products for each combination
        for res in itertools.product(*c):
            result.append(res)

print(result)

>>> result
# 3 + 3 + 2 = 8 singletons 
[('a',), ('b',), ('c',), (1,), (2,), (3,), ('x',), ('y',), 
# 3*3 + 3*2 + 3*2 = 21 pairs
('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1), ('c', 2), ('c', 3), 
('a', 'x'), ('a', 'y'), ('b', 'x'), ('b', 'y'), ('c', 'x'), ('c', 'y'),
(1, 'x'), (1, 'y'), (2, 'x'), (2, 'y'), (3, 'x'), (3, 'y'), 
# 3*3*2 = 18 triplets
('a', 1, 'x'), ('a', 1, 'y'), ('a', 2, 'x'), ('a', 2, 'y'), ('a', 3, 'x'), ('a', 3, 'y'), ('b', 1, 'x'), ('b', 1, 'y'), ('b', 2, 'x'), ('b', 2, 'y'), ('b', 3, 'x'), ('b', 3, 'y'), ('c', 1, 'x'), ('c', 1, 'y'), ('c', 2, 'x'), ('c', 2, 'y'), ('c', 3, 'x'), ('c', 3, 'y')]
  


-------------------------------------next answer-------------------------------------

Rank:10 (https://stackoverflow.com/questions/17910391)
  >>> from itertools import product
>>> list(product([0, 1], repeat=2))
[(0, 0), (0, 1), (1, 0), (1, 1)]
>>> 
>>> list(product([0, 1], repeat=3))
[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]
  

 To get list of list, you can do: 

  >>> map(list, list(product([0, 1], repeat=2)))
[[0, 0], [0, 1], [1, 0], [1, 1]]
  



