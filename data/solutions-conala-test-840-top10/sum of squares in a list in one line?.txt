Query: sum of squares in a list in one line?
-----------------------------------------------------------------------

Rank:1 (https://stackoverflow.com/questions/26894273)
 . Here it is using the  sum  function: 

  l = [1,2,3,4,5]
print(sum(i*i for i in l))
  


-------------------------------------next answer-------------------------------------

Rank:2 (https://stackoverflow.com/questions/26894484)
 For bigger list and when performance matters you should use numpy: 

  import numpy as np
l = [1,2,3,4,5]
arr = np.array(l)

np.sum(arr**2)
# or better:
np.dot(arr, arr)
  


-------------------------------------next answer-------------------------------------

Rank:3 (https://stackoverflow.com/questions/40918992)
 you are doing silly mistakes.  

  import random
xs = []
for i in range(3):
    xs.append(random.randint(0,50))

def sum_of_squares(xs):
    sum_of_squares=0  #mistake 1 : initialize sum first. you are making new sum variable in loop everytime. 
    for i in (xs):
        squared = i * i  #mistake 2 : ** is exponent and not multiply.
        sum_of_squares += squared  #mistake 3
    return sum_of_squares

print (sum_of_squares(xs))
  


-------------------------------------next answer-------------------------------------

Rank:4 (https://stackoverflow.com/questions/23260978)
 Simplest if you just want a line is  scipy.stats.linregress : 

  >>> from scipy import stats
>>> slope, intercept, r_value, p_value, std_err = stats.linregress(x,y)
  

 http://docs.scipy.org/doc/scipy-0.13.0/reference/generated/scipy.stats.linregress.html 


-------------------------------------next answer-------------------------------------

Rank:5 (https://stackoverflow.com/questions/40919398)
 Right the concept first on paper. 

 
 You have List of numbers. 
  You have to parse the List, do the square and save it to some variable. 

  import random

xs = []

#create three random numbers between 0 and 50

for i in range(3):
    xs.append(random.randint(0,50))

def sum_of_squares(xs):
    result = 0
    for i in xs:
        result += i*i

    return result
   
 


-------------------------------------next answer-------------------------------------

Rank:6 (https://stackoverflow.com/questions/26894268)
  

  sum(map(lambda x:x*x,l))
  

 we also use  reduce : 

  print reduce(lambda x,y: x+y*y,l) # as pointed by @espang reduce(lambda x,y: x+y*y,l) is only ok, when the first value is 1 (because 1*1 == 1). The first value is not squared
  

 We can take the first element, get its square, then add it to the head of the list so we can make sure that it's squared. . It isn't worth all that work, as we have better alternatives.  

  reduce(lambda x,y: x+y*y,[l[:1][0]**2]+l[1:])
  

 Just out of curiosity, I tried to compare the three solutions to sum the squares of  10000  numbers generated by  range , and compute the execution time of every operation.  

  l=range(10000) 
from datetime import datetime
start_time = datetime.now()
print reduce(lambda x,y: x+y*y,l)
print('using Reduce numbers: {}'.format(datetime.now() - start_time))

from datetime import datetime
start_time = datetime.now()
print sum(map(lambda x:x*x,l))
print('Sum after map square operation: {}'.format(datetime.now() - start_time))

from datetime import datetime
start_time = datetime.now()
print sum( i*i for i in l)
print('using list comprehension to sum: {}'.format(datetime.now() - start_time))
  

 Output:  

 Using  list comprehension  is faster  

  333283335000
using Reduce numbers: 0:00:00.003371
333283335000
Sum after map square operation: 0:00:00.002044
333283335000
using list comprehension to sum: 0:00:00.000916
  


-------------------------------------next answer-------------------------------------

Rank:7 (https://stackoverflow.com/questions/13215711)
 This might work: 

  def isSumOfSquares(n):
    """return True if n can be expressed as the sum of two squares; False otherwise"""

    for a in xrange(1,n):
        b = n-(a**2)
        if b<=0:
            return False
        elif not math.sqrt(b)%1:
            return True
    return False

answer = [i for i in xrange(1,1001) if isSumOfSquares(i**2)]
  

 Let me know if this works for you 


-------------------------------------next answer-------------------------------------

Rank:8 (https://stackoverflow.com/questions/14343800)
  

  for n in range(1,21):
    lst = range(1,21)
    squares = [x**2 for x in lst]
    for i in range(1, 21):
        for x in range(1, 21):
            if i in squares:
                if x in squares:
                    n2 = i+x
                    if n2 == n:
                        print n, " - Sum of Squares"

                    else:
                        print n, " - Not a Sum of Squares"
  

 Output: 

  >>> 
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
1  - Not a Sum of Squares
2  - Sum of Squares
2  - Not a Sum of Squares
...
  


-------------------------------------next answer-------------------------------------

Rank:9 (https://stackoverflow.com/questions/22358171)
 If I understand your question correctly, you have two dataset  x  and  y  which you want to perform a least square fit. 

 You don't have to write the algorithm yourself,  curve_fit  from  scipy.optimize  should do what you want, try: 

  from scipy.optimize import curve_fit

def f(x, A, B): # this is your 'straight line' y=f(x)
    return A*x + B

A,B = curve_fit(f, x, y)[0] # your data x, y to fit
  

  A , B  would be the slope and intercept for straight line 

 for more details and examples, see:
http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit  



